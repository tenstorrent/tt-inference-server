name: Create Release

on:
  workflow_dispatch:
    inputs:
      release-candidate-run-id:
        description: "Run ID of the on-release-candidates.yml workflow run (from tt-shield repo)"
        required: true
        type: string
      release-increment:
        description: "Version increment type"
        required: true
        type: choice
        options:
          - patch
          - minor
          - major

permissions:
  actions: read
  contents: write
  packages: write
  pull-requests: write

env:
  GH_TOKEN: ${{ github.token }}

jobs:
  check-prerequisites:
    runs-on: ubuntu-latest
    steps:
      - name: Check release increment input
        run: |
          INCREMENT="${{ inputs.release-increment }}"

          if [ -z "$INCREMENT" ]; then
            echo "❌ Error: Release increment must be specified"
            exit 1
          fi

          if [[ "$INCREMENT" != "patch" && "$INCREMENT" != "minor" && "$INCREMENT" != "major" ]]; then
            echo "❌ Error: Invalid release increment: $INCREMENT"
            echo "Valid options are: patch, minor, major"
            exit 1
          fi

          echo "✓ Release increment validated: $INCREMENT"

      - name: Check if workflow run exists and is of correct type
        env:
          GH_TOKEN: ${{ secrets.TMP_VMAKSIMOVICTT_PAT }}
        run: |
          set +e

          RUN_ID="${{ inputs.release-candidate-run-id }}"

          if ! [[ "$RUN_ID" =~ ^[0-9]+$ ]]; then
            echo "❌ Error: Invalid run ID format. Run ID must be a number."
            exit 1
          fi

          RUN_INFO=$(gh api repos/tenstorrent/tt-shield/actions/runs/$RUN_ID 2>&1)
          EXIT_CODE=$?

          if [ $EXIT_CODE -ne 0 ]; then
            echo "❌ Error: Workflow run $RUN_ID not found or not accessible."
            echo "$RUN_INFO"
            exit 1
          fi

          WORKFLOW_PATH=$(echo "$RUN_INFO" | jq -r '.path // empty')
          if [ -z "$WORKFLOW_PATH" ] || [ "$WORKFLOW_PATH" = "null" ]; then
            echo "❌ Error: Could not determine workflow path from run $RUN_ID"
            exit 1
          fi

          if [[ "$WORKFLOW_PATH" != *"release.yml"* ]]; then
            echo "❌ Error: Workflow run $RUN_ID is not of type 'on-release-candidates.yml'"
            echo "Found: $WORKFLOW_PATH"
            exit 1
          fi

          echo "✓ Workflow run $RUN_ID verified as 'on-release-candidates.yml'"

  create-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout dev branch
        uses: actions/checkout@v4
        with:
          ref: dev
          fetch-depth: 1

      - name: Run models CI reader
        env:
          GH_PAT: ${{ secrets.TMP_VMAKSIMOVICTT_PAT }}
        run: |
          python3 scripts/release/models_ci_reader.py --run-id ${{ inputs.release-candidate-run-id }}

      - name: Check for generated file
        id: check-file
        run: |
          # Find the generated file matching the pattern
          GENERATED_FILE=$(find release_logs -name "models_ci_last_good_*_to_*.json" -type f | head -n 1)

          if [ -z "$GENERATED_FILE" ]; then
            echo "❌ Error: No file found matching pattern 'release_logs/models_ci_last_good_*_to_*.json'"
            exit 1
          fi

          echo "✓ Found generated file: $GENERATED_FILE"
          echo "last_good_ci_json_path=$GENERATED_FILE" >> "$GITHUB_OUTPUT"

          echo ""
          echo "=== Contents of $GENERATED_FILE ==="
          cat "$GENERATED_FILE"
          echo "=== End of file contents ==="

      - name: Update model spec
        run: |
          python3 scripts/release/update_model_spec.py "${{ steps.check-file.outputs.last_good_ci_json_path }}"

      - name: Show git diff
        run: |
          echo "=== Git Diff Output ==="
          git diff
          echo "=== End of Git Diff ==="

      - name: Install crane
        run: |
          CRANE_VERSION="v0.20.7"
          ARCH="x86_64"
          OS="Linux"

          echo "Installing crane ${CRANE_VERSION} for ${OS}"
          curl -fsSL "https://github.com/google/go-containerregistry/releases/download/${CRANE_VERSION}/go-containerregistry_${OS}_${ARCH}.tar.gz" -o crane.tar.gz
          tar -xzf crane.tar.gz crane
          sudo mv crane /usr/local/bin/crane
          chmod +x /usr/local/bin/crane
          rm crane.tar.gz
          crane version

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: acvejicTT
          password: ${{ secrets.TMP_VMAKSIMOVICTT_PAT }}
          # username: ${{ github.repository_owner }}
          # password: ${{ github.token }}

      - name: Make release image artifacts
        run: |
          python3 scripts/release/make_release_image_artifacts.py "${{ steps.check-file.outputs.last_good_ci_json_path }}" --increment ${{ inputs.release-increment }} --dev

      - name: Read VERSION file
        id: read-version
        run: |
          # Check if VERSION file has been changed (and if it exists at all)
          if ! git diff --name-only | grep -q "^VERSION$" && ! git diff --cached --name-only | grep -q "^VERSION$"; then
            echo "❌ Error: VERSION file has NOT been changed"
            exit 1
          fi

          VERSION=$(cat VERSION | tr -d '[:space:]')

          # Validate version format (x.y.z)
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "❌ Error: Invalid version format: $VERSION"
            echo "Expected format: x.y.z (where x, y, z are positive whole numbers)"
            exit 1
          fi

          BRANCH_NAME="pre-release-v${VERSION}"

          echo "✅ VERSION file has been changed"
          echo "✓ Read version: $VERSION"
          echo "✓ Branch name: $BRANCH_NAME"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "branch_name=$BRANCH_NAME" >> "$GITHUB_OUTPUT"

      - name: Configure git
        run: |
          git config user.name "vmaksimovicTT"
          git config user.email "vmaksimovic@tenstorrent.com"

      - name: Create pre-release branch
        run: |
          BRANCH_NAME="${{ steps.read-version.outputs.branch_name }}"

          echo "Creating branch: $BRANCH_NAME"
          git checkout -b "$BRANCH_NAME"
          echo "✓ Created branch: $BRANCH_NAME"

      - name: Commit changes and push branch
        run: |
          BRANCH_NAME="${{ steps.read-version.outputs.branch_name }}"
          git add -A

          git commit -m "Release candidate v${{ steps.read-version.outputs.version }}: Update model spec and version"
          echo "✓ Committed all changes"
          git push -u origin "$BRANCH_NAME"

      - name: Create PR
        # env:
        #   GH_TOKEN: ${{ secrets.TMP_DEMO_RELEASE }}
        run: |
          BRANCH_NAME="${{ steps.read-version.outputs.branch_name }}"
          PR_TITLE="Release Candidate v${{ steps.read-version.outputs.version }}"

          # Build PR body from markdown files
          PR_BODY_FILE=$(mktemp)
          echo "# Summary of Changes" > "$PR_BODY_FILE"
          echo "" >> "$PR_BODY_FILE"

          # Add model spec updates if file exists
          if [ -f "release_logs/release_models_diff.md" ]; then
            cat "release_logs/release_models_diff.md" >> "$PR_BODY_FILE"
            echo "" >> "$PR_BODY_FILE"
          fi

          # Add release artifacts summary if file exists
          if [ -f "release_logs/dev_artifacts_summary.md" ]; then
            cat "release_logs/dev_artifacts_summary.md" >> "$PR_BODY_FILE"
          fi

          echo "Creating draft PR: $PR_TITLE"
          gh pr create \
            --title "$PR_TITLE" \
            --body-file "$PR_BODY_FILE" \
            --base dev \
            --head "$BRANCH_NAME" \
            --draft

          rm -f "$PR_BODY_FILE"
          echo "✓ Created draft PR for $BRANCH_NAME"

      # - name: Create release assets
      #   id: create-assets
      #   run: |
      #     RELEASE_TAG="v${{ steps.read-version.outputs.version }}"
      #     WORKFLOW_LOGS="${RELEASE_TAG}-release-artifacts.zip"

      #     # Name source code assets to match GitHub's automatic source code asset pattern
      #     # GitHub displays these as "Source code (zip)" and "Source code (tar.gz)"
      #     REPO_ZIP="tt-inference-server-${RELEASE_TAG}.zip"
      #     REPO_TAR_GZ="tt-inference-server-${RELEASE_TAG}.tar.gz"

      #     if [ -d "release_logs/ci_run_logs" ]; then
      #       echo "Creating zip file with workflow logs..."
      #       cd release_logs/ci_run_logs
      #       # cd into the only folder (we don't know its name)
      #       if [ -z "$(ls -A)" ]; then
      #         echo "❌ Error: release_logs/ci_run_logs is empty"
      #         exit 1
      #       fi
      #       cd */
      #       # Now zip all workflow_logs_* folders from this location
      #       zip -r "../../../${WORKFLOW_LOGS}" workflow_logs_* 2>/dev/null || {
      #         echo "❌ Error: No workflow_logs_* folders found in release_logs/ci_run_logs/*/"
      #         exit 1
      #       }
      #       cd ../../..
      #     else
      #       echo "❌ Error: release_logs/ci_run_logs directory not found"
      #       exit 1
      #     fi

      #     echo "Creating archives of tt-inference-server repo..."
      #     cd ..
      #     zip -r "${REPO_ZIP}" tt-inference-server || {
      #       echo "❌ Error: Failed to create zip archive of tt-inference-server"
      #       exit 1
      #     }
      #     tar -czf "${REPO_TAR_GZ}" tt-inference-server || {
      #       echo "❌ Error: Failed to create tar.gz archive of tt-inference-server"
      #       exit 1
      #     }
      #     cd tt-inference-server

      #     # Export asset paths as newline-separated list
      #     ASSET_PATHS="${WORKFLOW_LOGS}"$'\n'"../${REPO_ZIP}"$'\n'"../${REPO_TAR_GZ}"
      #     echo "assets<<EOF" >> "$GITHUB_OUTPUT"
      #     echo "${ASSET_PATHS}" >> "$GITHUB_OUTPUT"
      #     echo "EOF" >> "$GITHUB_OUTPUT"

      #     echo "✓ Created release assets: ${WORKFLOW_LOGS}, ${REPO_ZIP}, ${REPO_TAR_GZ}"

      # - name: Create release
      #   env:
      #     GH_TOKEN: ${{ secrets.TMP_DEMO_RELEASE }}
      #   run: |
      #     RELEASE_TAG="v${{ steps.read-version.outputs.version }}"

      #     # Build release notes from markdown files
      #     RELEASE_NOTES_FILE=$(mktemp)
      #     echo "# Summary of Changes" > "$RELEASE_NOTES_FILE"
      #     echo "" >> "$RELEASE_NOTES_FILE"

      #     # Add model spec updates if file exists
      #     if [ -f "release_logs/release_models_diff.md" ]; then
      #       cat "release_logs/release_models_diff.md" >> "$RELEASE_NOTES_FILE"
      #       echo "" >> "$RELEASE_NOTES_FILE"
      #     fi

      #     # Add release artifacts summary if file exists
      #     if [ -f "release_logs/dev_artifacts_summary.md" ]; then
      #       cat "release_logs/dev_artifacts_summary.md" >> "$RELEASE_NOTES_FILE"
      #     fi

      #     # Read asset paths from previous step output into array
      #     IFS=$'\n' read -d '' -r -a ASSET_ARRAY <<< "${{ steps.create-assets.outputs.assets }}" || true

      #     echo "Creating draft release: ${RELEASE_TAG}"

      #     # Create release first without assets
      #     gh release create "${RELEASE_TAG}" \
      #       --repo "${{ github.repository }}" \
      #       --draft \
      #       --title "${RELEASE_TAG}" \
      #       --notes-file "$RELEASE_NOTES_FILE" || {
      #         echo "❌ Error: Failed to create release"
      #         rm -f "$RELEASE_NOTES_FILE"
      #         exit 1
      #     }

      #     # Upload assets separately
      #     echo "Uploading ${#ASSET_ARRAY[@]} asset(s): ${ASSET_ARRAY[*]}"
      #     for asset in "${ASSET_ARRAY[@]}"; do
      #       if [ -f "$asset" ]; then
      #         echo "Uploading: $asset"
      #         gh release upload "${RELEASE_TAG}" "$asset" \
      #           --repo "${{ github.repository }}" || {
      #             echo "⚠️  Warning: Failed to upload asset: $asset"
      #           }
      #       else
      #         echo "⚠️  Warning: Asset file not found: $asset"
      #       fi
      #     done

      #     rm -f "$RELEASE_NOTES_FILE"
      #     echo "✓ Created draft release: ${RELEASE_TAG}"

      - name: Cleanup on failure
        if: failure()
        run: |
          BRANCH_NAME="${{ steps.read-version.outputs.branch_name }}"

          echo "Cleaning up branch: $BRANCH_NAME"
          git push origin --delete "$BRANCH_NAME" || echo "⚠️  Failed to delete branch (may not exist or already deleted)"
          echo "✓ Cleanup completed"
